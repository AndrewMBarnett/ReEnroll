#!/bin/bash

# shellcheck disable=SC2034,SC2317

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Script Information
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Script Version
scriptVersion="1.0"
# Script Name
scriptName="ReEnroll"
# Log file for script
scriptLog="/var/log/ReEnrollComputers.log"
# Temporary inventory log to read
tempInventoryLog="/var/log/tempInventory.log"
# Set the custom folder path for the receipt file
folder_path="/usr/local/reenroll/receipts"
# Receipt Path for Extension attribute
receipt_path="/usr/local/reenroll/receipts/reEnrollComputer.txt"

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# API Inormation
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# API information (ReEnroll API Credentials)
client_id="$4"
client_secret="$5"

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Skip Check-In, LAPS Admin Account Username and User to Exempt/Target for Deletion Options
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Skip Jamf connection verification after enrollment
skipCheckIN="false"                                                 # [ false (default) | true ]
# Skip LAPS admin account verification after enrollment
skipLAPSAdminCheck="false"                                          # [ false (default) | true ]
# LAPS admin account username (add the Jamf managed local admin account username here)
lapsAdminAccount="$6"                                                 # [ add the LAPS admin account username here ]
# Skip User Exemption/Targeted Deletion
skipAccountDeletion="false"                                         # [ false (default) | true ]
# Define the exempt user list from being deleted (Add the username in quotes, with a space in between each)
exempt_users=("Shared" "Guest" "$loggedInUser")                     # [ add the exempt user list here ]
# Define the targeted user list to be deleted (Add the username in quotes, with a space in between each) 
targeted_users=("$lapsAdminAccount" "anotherAccount" )              # [ add the targeted user list here ]
# Jamf Enrollment Invitation ID (https:/company.jamfcloud.com/enroll?invitation=1542270881__;!!KwNVnq) (Invitation ID in this example would be: 1542270881)
enrollmentInvitation="$7"                                             # [ add the Invitation ID here ]

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# ReEnroll Computers Options
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Send redeploy Jamf Management Framework command
redeployFramework="true"                                     # [ true (default) | false ]
# Send enrollment invitation command
sendEnrollmentInvitation="failure"                           # [ true  | false | failure (default) ]
# Send profiles renew -type command
renewProfiles="failure"                                      # [ true | false | failure (default) ]

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Launch Daemon information 
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Skip Launch Daemon after script completion 
skipLaunchDaemon="false"                                     # [ false (default) | true ]
# Launch Daemon information
organizationName="company"                                   # [ add the organization name here ] #
organizationReverseDomain="com.company"                      # [ add the organization reverse domain here ]

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Additional Settings
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Add additional logging
debugMode="false"			                                 # Debug Mode [ false (default) | verbose ] Verbose adds additional logging
# Verify and Update Computer Site after enrollment
updateComputerSite="true"                                    # Update Computer Site [ true (default) | false ]
# Move Computer to new Site
newComputerSiteID=""                                         # Move Computer Site [ blank (default) ] (Only used if updateComputerSite is true and newComputerSiteName is set)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Swift Dialog Settings
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Display a ReEnroll progress dialog
displayReEnrollDialog="$8"                                    # Display ReEnroll Dialog [ true | false (default) ]
# Unattended Exit Options
unattendedExit="true"                                         # Unattended Exit [ true | false (default) ]
# Unattended Exit Seconds
unattendedExitSeconds="30"                                    # Number of seconds to wait until a kill Dialog command is sent
# Minimum version of swiftDialog required to use workflow
swiftDialogMinimumRequiredVersion="2.5.2"                     # Minimum version of swiftDialog required to use workflow
# Version of swiftDialog
dialogVersion=$( /usr/local/bin/dialog --version )
# Timestamp with computer timezone
timestamp=$(date +"%Y-%m-%d %I:%M:%S %p %Z")
# Dialog Binary
dialogBinary="/usr/local/bin/dialog"
# Dialog temporary command files
dialogLog=$( mktemp -u /var/tmp/dialogLog.XXX )
updateDialogLog=$( mktemp -u /var/tmp/updateDialogLog.XXX )

# Set icon based on whether the Mac is a desktop or laptop
if system_profiler SPPowerDataType | grep -q "Battery Power"; then
    icon="SF=arrow.triangle.2.circlepath.icloud.fill,weight=regular,colour1=black,colour2=white"
else
    icon="SF=arrow.triangle.2.circlepath.icloud.fill,weight=regular,colour1=black,colour2=white"
fi

### Overlay Icon ###
useOverlayIcon="true"								# Toggles swiftDialog to use an overlay icon [ true (default) | false ]

# Create `overlayicon` from Self Service's custom icon (thanks, @meschwartz!)
if [[ "$useOverlayIcon" == "true" ]]; then
    xxd -p -s 260 "$(defaults read /Library/Preferences/com.jamfsoftware.jamf self_service_app_path)"/Icon$'\r'/..namedfork/rsrc | xxd -r -p > /var/tmp/overlayicon.icns
    overlayicon="/var/tmp/overlayicon.icns"
else
    overlayicon=""
fi

### Webhook Options ###

webhookEnabled="false"                                                          # Enables the webhook feature [ all | failures | false (default) ]
teamsURL=""                                                                     # Teams webhook URL                         
slackURL=""                                                                     # Slack webhook URL

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Operating System Variables and Jamf URL
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Current JSS address
jssurl=$(/usr/bin/defaults read /Library/Preferences/com.jamfsoftware.jamf.plist jss_url)
# Jamf Pro URL for on-prem, multi-node, clustered environments (Used for webhook url button)
case ${jssurl} in
    *"test"*    ) jamfProURL="https://test.jamfcloud.com" ;;
    *"prod"*    ) jamfProURL="https://prod.jamfcloud.com" ;;
    *           ) jamfProURL="https://prod.jamfcloud.com" ;;
esac
# Get Computer Serial Number
serialNumber=$(ioreg -rd1 -c IOPlatformExpertDevice | awk -F'"' '/IOPlatformSerialNumber/{print $4}')
# Get Computer Name
computerName=$( scutil --get ComputerName )
# Jamf Pro Computer URL for Webhook Message
jamfProComputerURL="${jssurl}/computers.html?query=${serialNumber}&queryType=COMPUTERS"
# Get the current major OS version
osVersion=$(/usr/bin/sw_vers -productVersion | /usr/bin/cut -d"." -f1)
osVersionFull=$(/usr/bin/sw_vers -productVersion)
osVersionExtra=$(/usr/bin/sw_vers -productVersionExtra)
osBuild=$( sw_vers -buildVersion )
osMajorVersion=$( echo "${osVersion}" | awk -F '.' '{print $1}' )
modelName=$( /usr/libexec/PlistBuddy -c 'Print :0:_items:0:machine_name' /dev/stdin <<< "$(system_profiler -xml SPHardwareDataType)" )

echo "model name is $modelName"

# Report RSR sub-version if applicable
if [[ -n $osVersionExtra ]] && [[ "${osMajorVersion}" -ge 13 ]]; then osVersion="${osVersion} ${osVersionExtra}"; fi

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# IT Support Variable
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

### Support Team Details ###


supportTeamName="Add IT Support"
supportTeamPhone="Add IT Phone Number"
supportTeamEmail="Add email"
supportTeamWebsite="Add IT Help site"
supportTeamHyperlink="[${supportTeamWebsite}](https://${supportTeamWebsite})"

# Create the help message based on Support Team variables
helpMessage="If you need assistance, please contact ${supportTeamName}:  \n- **Telephone:** ${supportTeamPhone}  \n- **Email:** ${supportTeamEmail}  \n- **Help Website:** ${supportTeamHyperlink}  \n\n**Computer Information:**  \n- **Operating System:**  $osVersion ($osBuild)  \n- **Serial Number:** $serialNumber  \n- **Dialog:** $dialogVersion  \n- **Started:** $timestamp  \n- **Script Version:** $scriptVersion"

####################################################################################################
#
# Functions
#
####################################################################################################

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Client-side Logging
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

function updateScriptLog() {
    echo "${scriptName} ($scriptVersion): $(date +%Y-%m-%d\ %H:%M:%S) - ${1}" | tee -a "${scriptLog}"
}

function preFlight() {
    updateScriptLog "[PRE-FLIGHT]      ${1}"
}

function notice() {
    updateScriptLog "[NOTICE]          ${1}"
}

function infoOut() {
    updateScriptLog "[INFO]            ${1}"
}

function debugVerbose() {
    if [[ "$debugMode" == "verbose" ]]; then
        updateScriptLog "[DEBUG VERBOSE]   ${1}"
    fi
}

function debug() {
    # shellcheck disable=SC2317
    if [[ "$debugMode" == "true" ]]; then
        updateScriptLog "[DEBUG]           ${1}"
    fi
}

function errorOut() {
    updateScriptLog "[ERROR]           ${1}"
}

function error() {
    updateScriptLog "[ERROR]           ${1}"
    (( errorCount++ )) || true
}

function warning() {
    updateScriptLog "[WARNING]         ${1}"
    (( errorCount++ )) || true
}

function fatal() {
    updateScriptLog "[FATAL ERROR]     ${1}"
    exit 1
}

function quitOut() {
    updateScriptLog "[QUIT]            ${1}"
}

####################################################################################################
#
# Pre-flight Checks
#
####################################################################################################

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Pre-flight Check: Client-side Logging
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Create the log file if it does not exist
if [[ ! -f "${scriptLog}" ]]; then
    touch "${scriptLog}"
    if [[ -f "${scriptLog}" ]]; then
        preFlight "Created specified scriptLog"
    else
        fatal "Unable to create specified scriptLog '${scriptLog}'; exiting.\n\n(Is this script running as 'root' ?)"
    fi
else
    preFlight "Specified scriptLog exists; writing log entries to it"
fi

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Pre-flight Check: Validate / Create Temp DialogLog File
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

if [[ ! -f "${dialogLog}" ]]; then
    touch "${dialogLog}"
    if [[ -f "${dialogLog}" ]]; then
        preFlight "Created specified dialogLog"
    else
        fatal "Unable to create specified dialogLog; exiting.\n\n(Is this script running as 'root' ?)"
    fi
else
    preFlight "Specified dialogLog exists; proceeding …"
fi

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Update Dialog
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

function updateDialog() {
    echo "${1}" >> "${dialogLog}"
    sleep 0.4
}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Pre-flight Check: Validate / Create temp Inventory Log File
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Jamf Log Location
jamfLogFile="/var/log/jamf.log"
# Create the temp inventory log file if it does not exist
duplicate_log_dir=$( mktemp -d /var/tmp/jamfTemp.XXXXXX )
# Marker file for last log position
marker_file="/var/tmp/jamfTempMarker.txt"

# Give the directory the correct permissions
chmod 655 "$duplicate_log_dir"

# Create the inventory log file if it does not exist
if [[ ! -f "${tempInventoryLog}" ]]; then
    touch "${tempInventoryLog}"
    if [[ -f "${tempInventoryLog}" ]]; then
        preFlight "Created specified inventoryLog"
    else
        fatal "Unable to create specified $tempInventoryLog; exiting.\n\n(Is this script running as 'root' ?)"
    fi
else
    preFlight "Specified $tempInventoryLog exists; proceeding …"
fi

# Create a marker file if it doesn't exist
function createMarkerFile(){

# 
if [ ! -f "$marker_file" ]; then
        preFlight "Marker file not found, creating temp marker file"
        touch "$marker_file"
        else
        preFlight "marker file exist, continuing"
     fi
}

# Create last log position
function createLastLogPosition() {
    
  # Create a timestamp for the current run
    timestamp=$(date +%Y%m%d%H%M%S)
    preFlight "Current time stamp: $timestamp"

    # Create a directory for duplicate log files if it doesn't exist
     if [ ! -d "$duplicate_log_dir" ]; then
        mkdir -p "$duplicate_log_dir"
        preFlight "Creating duplicate log file"
        else
        preFlight "Duplicate log directory exists, continuing"
     fi

     # Create a directory for duplicate log files if it doesn't exist
     if [ ! -f "$marker_file" ]; then
        preFlight "Marker file not found, creating temp marker file"
        touch "$marker_file"
        else
        preFlight "marker file exist, continuing"
     fi

    # Specify the duplicate log file with a timestamp
    duplicate_jamfLogFile="$duplicate_log_dir/jamf_position_$timestamp.log"
    preFlight "Duplicate Log File location: $duplicate_jamfLogFile"

    # Find the last position marker or start from the beginning if not found
    if [[ -f "$marker_file" && -f $jamfLogFile ]]; then
        lastPosition=$(cat "$marker_file")
    else 
        preFlight "Creating jamf log file and setting error position as zero"
        touch "$jamfLogFile"
        chmod 755 "$jamfLogFile"
        lastPosition=0
    fi

    # Copy new entries from jamf.log to the duplicate log file
    if [ -f "$jamfLogFile" ]; then
        tail -n +$((lastPosition + 1)) "$jamfLogFile" > "$duplicate_jamfLogFile"
        preFlight "jamf log file exists. Tailing new entries from log file to duplicate log file" 
    else 
        error "jamf log file not found"
    fi

    # Update the marker file with the new position
    wc -l "$jamfLogFile" | awk '{print $1}' > "$marker_file"
    preFlight "Updating marker file"

    # Echo out the last position on the marker file
    lastPosition=$(cat "$marker_file")
    preFlight "Last position of marker file: $lastPosition"
}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Checking Last Error Position
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Verify last position location in log file from previous run
function verifyLastPosition(){
 # Find the last position text in scriptLog
   lastPosition_line=$(tail -n 400 "$scriptLog" | grep 'Last position:' | tail -n 1)

    if [ -n "$lastPosition_line" ]; then
        # Extract the last position from the line
        lastPosition=$(echo "$lastPosition_line" | awk -F 'Last position:' '{print $2}' | tr -d '[:space:]')

        echo "$lastPosition" > "$marker_file"

        # Check if last position is less than or equal to zero
        if [[ ! -f "{$jamfLogFile}" ]] || [[ "${lastPosition}" -le 0 ]]; then
            preFlight "Last position is less than one or jamf log doesn't exist. Creating position."
            createLastLogPosition
        else
            preFlight "Last position is greater than zero and jamf log file exists. Continuing."
            lastPositionUpdated=$(cat "$marker_file")
            preFlight "Last position: $lastPositionUpdated"
        fi
    else
        preFlight "Last position not found. Setting it to zero and continuing."
        createLastLogPosition
    fi
}

preFlight "Creating Marker file and checking if last error position exists"
createMarkerFile
verifyLastPosition

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Pre-flight Check: Confirm script is running as root
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Confirm script is running as root
if [[ $(id -u) -ne 0 ]]; then
    fatal "This script must be run as root; exiting."
fi

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Pre-flight Check: Confirm Dock is running / user is at Desktop
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

until pgrep -q -x "Finder" && pgrep -q -x "Dock"; do
    preFlight "Finder & Dock are NOT running; pausing for 1 second"
    sleep 1
done

preFlight "Finder & Dock are running; proceeding …"


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Pre-flight Check: Current Logged-in User Function
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

function currentLoggedInUser() {
    loggedInUserAccount=$( echo "show State:/Users/ConsoleUser" | scutil | awk '/Name :/ { print $3 }' )
    preFlight "Current Logged-in User: ${loggedInUserAccount}"
}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Pre-flight Check: Validate Logged-in System Accounts
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Get the currently logged-in user
function currentLoggedInUser() {

    loggedInCounter="1"

    until { [[ "${loggedInUserAccount}" != "_mbsetupuser" ]] || [[ "${loggedInCounter}" -gt "180" ]]; } && { [[ "${loggedInUserAccount}" != "loginwindow" ]] || [[ "${loggedInCounter}" -gt "30" ]]; } ; do
    preFlight "Logged-in User Counter: ${loggedInCounter}"
    currentLoggedInUser
    sleep 2
    ((loggedInCounter++))
    done

    if [[ "$debugMode" = "verbose" ]]; then
        loggedInUser=$(echo "show State:/Users/ConsoleUser" | scutil | awk '/Name :/ { print $3 }')
            debugVerbose "Current Logged-in User: ${loggedInUser}"
        uid=$(/usr/bin/id -u "${loggedInUser}")
            debugVerbose "User ID: ${uid}"
        networkUser="$(dscl . -read /Users/"$loggedInUser" | grep "NetworkUser" | cut -d " " -f 2)"
            debugVerbose "Network User is $networkUser"
        loggedInUserFullname=$(id -F "${loggedInUser}")
        loggedInUserFirstname=$(echo "$loggedInUserFullname" | sed -E 's/^.*, // ; s/([^ ]*).*/\1/' | sed 's/\(.\{25\}\).*/\1…/' | awk '{print ( $0 == toupper($0) ? toupper(substr($0,1,1))substr(tolower($0),2) : toupper(substr($0,1,1))substr($0,2) )}')
        loggedInUserLastname=$(echo "$loggedInUserFullname" | sed "s/$loggedInUserFirstname//" | sed 's/,//g')
        loggedInUserID=$(id -u "${loggedInUser}")
            debugVerbose "Current Logged-in User First Name: ${loggedInUserFirstname}"
            debugVerbose "Current Logged-in User Full Name: ${loggedInUserFirstname} ${loggedInUserLastname}"
            debugVerbose "Current Logged-in User ID: ${loggedInUserID}"
    else
        loggedInUser=$(echo "show State:/Users/ConsoleUser" | scutil | awk '/Name :/ { print $3 }')
        uid=$(/usr/bin/id -u "${loggedInUser}")
            preFlight "User ID: ${uid}"
        networkUser="$(dscl . -read /Users/"$loggedInUser" | grep "NetworkUser" | cut -d " " -f 2)"
            preFlight "Network User is $networkUser"
        loggedInUserFullname=$(id -F "${loggedInUser}")
        loggedInUserFirstname=$(echo "$loggedInUserFullname" | sed -E 's/^.*, // ; s/([^ ]*).*/\1/' | sed 's/\(.\{25\}\).*/\1…/' | awk '{print ( $0 == toupper($0) ? toupper(substr($0,1,1))substr(tolower($0),2) : toupper(substr($0,1,1))substr($0,2) )}')
        loggedInUserLastname=$(echo "$loggedInUserFullname" | sed "s/$loggedInUserFirstname//" | sed 's/,//g')
        loggedInUserID=$(id -u "${loggedInUser}")
            preFlight "Current Logged-in User: ${loggedInUser}"
    fi


}

preFlight "Check for Logged-in System Accounts …"

currentLoggedInUser

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Validate / install swiftDialog (Thanks big bunches, @acodega!)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Download swiftDialog
function dialogInstall() {

    # Get the URL of the latest PKG From the Dialog GitHub repo
    dialogURL=$(curl -L --silent --fail "https://api.github.com/repos/swiftDialog/swiftDialog/releases/latest" | awk -F '"' "/browser_download_url/ && /pkg\"/ { print \$4; exit }")

    # Expected Team ID of the downloaded PKG
    expectedDialogTeamID="PWA5E9TQ59"

    preFlight "Installing swiftDialog..."

    # Create temporary working directory
    workDirectory=$( /usr/bin/basename "$0" )
    tempDirectory=$( /usr/bin/mktemp -d "/private/tmp/$workDirectory.XXXXXX" )

    # Download the installer package
    /usr/bin/curl --location --silent "$dialogURL" -o "$tempDirectory/Dialog.pkg"

    # Verify the download
    teamID=$(/usr/sbin/spctl -a -vv -t install "$tempDirectory/Dialog.pkg" 2>&1 | awk '/origin=/ {print $NF }' | tr -d '()')

    # Install the package if Team ID validates
    if [[ "$expectedDialogTeamID" == "$teamID" ]]; then
        /usr/sbin/installer -pkg "$tempDirectory/Dialog.pkg" -target /
        sleep 2
        dialogVersion=$( /usr/local/bin/dialog --version )
        preFlight "swiftDialog version ${dialogVersion} installed; proceeding..."
    else
        # Display a so-called "simple" dialog if Team ID fails to validate
        infoOut "Unable to verify swift dialog team ID. Not installing or udpating"
    fi
    # Remove the temporary working directory when done
    /bin/rm -Rf "$tempDirectory"
}

# Check for dialog and install if it's not found
function dialogCheck() {

    # Set swiftDialogMinimumRequiredVersion based on osMajorVersion
    if [ "$osMajorVersion" -lt 12 ]; then
      swiftDialogMinimumRequiredVersion="2.4.2"
    else
      swiftDialogMinimumRequiredVersion="2.5.2"
    fi

    # Check for Dialog and install if not found
    if [ ! -e "/Library/Application Support/Dialog/Dialog.app" ]; then
        preFlight "swiftDialog not found. Installing..."
        dialogInstall
    else
        dialogVersion=$(/usr/local/bin/dialog --version)
        if [[ "${dialogVersion}" < "${swiftDialogMinimumRequiredVersion}" ]]; then    
            preFlight "swiftDialog version ${dialogVersion} found but swiftDialog ${swiftDialogMinimumRequiredVersion} or newer is required; updating..."
            dialogInstall
        else
        preFlight "swiftDialog version ${dialogVersion} found; proceeding..."
        fi
    fi
}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Pre-flight Check: Validate Operating System
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Check for macOS 12 or higher
preFlight "Check for macOS ${osMajorVersion}..."
if [[ "${osMajorVersion}" -ge 12 ]] ; then
    preFlight "macOS ${osMajorVersion} installed; proceeding ..."
    dialogCheck
else
    preFlight "macOS ${osMajorVersion} installed; Using osascript"
    
fi

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Pre-flight Check: Complete
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

preFlight "Complete!"

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# "ReEnroll" Dialog Settings and Features
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

title="ReEnroll"
message=""
inventoryProgressText="Initializing …"

dialogReEnroll="$dialogBinary \
--title \"$title\" \
--titlefont \"name=Arial, size=25\" \
--icon \"$icon\" \
--message \"\" \
--overlayicon \"$overlayicon\" \
--helpmessage \"$helpMessage\" \
--height 450 \
--width 725 \
--windowbuttons min \
--position center \
--ontop \
--button1text \"Close\" \
--moveable \
--listitem \"ReEnroll in progress …\" \
--progress \
--titlefont size=20 \
--messagefont size=14 \
--infobox \"**Computer Name:**  \n\n • $computerName  \n\n **macOS Version:**  \n\n • $osVersionFull\" \
--progresstext \"$inventoryProgressText\" \
--quitkey K \
--commandfile \"$dialogLog\" "


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Setup List for ReEnroll Window
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

function evalReEnrollDialog() {

    notice "Create ReEnroll dialog …"
    eval "$dialogReEnroll" &

    updateDialog "listitem: delete, title: ReEnroll in progress …"

    updateDialog "progresstext: Initializing…"

}


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Kill a specified process (thanks, @grahampugh!)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

function killProcess() {

    process="$1"
    if process_pid=$( pgrep -a "${process}" 2>/dev/null ) ; then
        infoOut "Attempting to terminate the '$process' process …"
        infoOut "(Termination message indicates success.)"
        kill "$process_pid" 2> /dev/null
        if pgrep -a "$process" >/dev/null ; then
            errorOut "'$process' could not be terminated."
        fi
    else
        infoOut "The '$process' process isn't running."
    fi

}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Exit the Dialog
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

function dialogExit() {

    if [[ "$unattendedExit" == "true" ]]; then
        infoOut "Unattended exit set to 'true', waiting $unattendedExitSeconds seconds then sending kill to Dialog"
        infoOut "Killing the dialog"
        killProcess "Dialog"
    else
        infoOut "Unattended exit set to 'false', leaving dialog on screen"
    fi

}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Quit Script
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Quit Script function
function quitScript() {

# WebHook Message
case ${webhookEnabled} in

    "all" ) # Notify on sucess and failure 
        infoOut "Webhook Enabled flag set to: ${webhookEnabled}, continuing ..."
            webHookMessage
    ;;

    "failures" ) # Notify on failures
        if [[ "${errorCount}" -gt 0 ]]; then
            warning "Completed with $errorCount errors."
            infoOut "Webhook Enabled flag set to: ${webhookEnabled} with error count: ${errorCount}, continuing ..."
            webHookMessage
        else
            infoOut "Webhook Enabled flag set to: ${webhookEnabled}, but conditions not met for running webhookMessage."
        fi
    ;;

    "false" ) # Don't notify
        infoOut "Webhook Enabled flag set to: ${webhookEnabled}, skipping ..."
    ;;

    * ) # Catch-all
        infoOut "Webhook Enabled flag set to: ${webhookEnabled}, skipping ..."
        ;;

esac
    # Update computer inventory after enrollment
     function updatedComputerInventoryInfo () {
    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
    # Update Computer Site
    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    # Update Computer Site
    function computerSiteUpdate () {

            infoOut "Computer has an original Site: ($computerSite), site ID: ($computerSiteID)"
            /usr/bin/curl --request PATCH \
            --url "${jssurl}api/v1/computers-inventory-detail/$computerID" \
            --header "Authorization: Bearer $apiBearerToken" \
            --header 'accept: application/json' \
            --header 'Content-Type: application/json' \
            --data "{
            \"general\": {
                \"siteId\": \"$computerSiteID\"
            }
            }"
    }
        # Update Computer Site to new site
        function newComputerSiteUpdate () {

            infoOut "Computer has an original Site: ($computerSite)"
            /usr/bin/curl --request PATCH \
            --url "${jssurl}api/v1/computers-inventory-detail/$computerID" \
            --header "Authorization: Bearer $apiBearerToken" \
            --header 'accept: application/json' \
            --header 'Content-Type: application/json' \
            --data "{
            \"general\": {
                \"siteId\": \"$newComputerSiteID\"
            }
            }"
    }
    
        # Verify and update computer site
        if [ "$updateComputerSite" = "true" ]; then
            infoOut "Update computer site is set to true, verifying and updating computer Site"
            getAccessToken
            checkTokenExpiration
            computerInventoryInfo
            if [ ! "$newComputerSiteID" = "" ]; then
                # Updating computer site
                newComputerSiteUpdate
                notice "New Computer Site ID: $newComputerSiteID"
            elif [ "$computerSiteID" -gt "1" ]; then
                computerSiteUpdate
                notice "The computer ($serialNumber) was updated to the original site ($computerSite)."
            elif [ "$computerSiteID" -lt "0" ]; then
                # Computer Site ID less than zero, assigned to no site
                notice "The computer ($serialNumber) Site was set to none."
            else
                error "The computer was not updated to the original site"
            fi
    else
        infoOut "Update computer site is set to false, skipping verifying and updating computer Site"
    fi
    }

    # Invalidate the Bearer Token
    invalidateToken () {
	responseCode=$(/usr/bin/curl -w "%{http_code}" -H "Authorization: Bearer ${apiBearerToken}" "${jssurl}api/v1/auth/invalidate-token" -X POST -s -o /dev/null)
	if [[ ${responseCode} == 204 ]]
	then
		quitOut "Token successfully invalidated"
		access_token=""
		token_expiration_epoch="0"
	elif [[ ${responseCode} == 401 ]]
	then
		quitOut "Token already invalid"
	else
		quitOut "An unknown error occurred invalidating the token"
        apiBearerToken=$(/usr/bin/curl "${jssurl}api/v1/auth/invalidate-token" --silent --header "Authorization: Bearer ${apiBearerToken}" -X POST)
        apiBearerToken=""
	fi
    }
	
        # Functions for script
    if [ "$displayReEnrollDialog" = "true" ]; then
        infoOut "Display ReEnroll Dialog is set to true, completing ReEnroll Dialog"
        # Complete ReEnroll Dialog Window
        completeReEnrollDialog
    else
        # displayReEnrollDialog was set to false
        notice "No Dialog was displayed, no ReEnroll Dialog to complete"
    fi

    if [ -z "$client_id" ] || [ -z "$client_secret" ] || [ "$APIAccess" = "Failure" ]; then
        notice "Client ID and Client Secret not set, skipping computer site update"
    else
        # Check computer site information
        updatedComputerInventoryInfo
    fi

    # Invalidate the Bearer Token
    invalidateToken

    # Stop the `Dialog` process
    dialogExit

    # Remove functions
    # Remove if exists
    function rm_if_exists()
    {
    if [ -n "${1}" ] && [ -e "${1}" ];then
        /bin/rm -r "${1}"
    fi
    }

    # Remove inventoryLog
    if [[ -f "${tempInventoryLog}" ]]; then
        quitOut "Removing ${tempInventoryLog} …"
        rm "${tempInventoryLog}"
    fi

        # Remove duplicate log file
    if [[ -d "${duplicate_log_dir}" ]]; then
        quitOut "Removing ${duplicate_log_dir} …"
        rm_if_exists "${duplicate_log_dir}"
        else
        quitOut "Could not delete ${duplicate_log_dir}"

    fi

     # Remove Marker File
    if [[ -e ${marker_file} ]]; then
        quitOut "Removing ${marker_file} …"
        rm "${marker_file}"
    fi

    # Remove dialogLog
    if [[ -f "${dialogLog}" ]]; then
        infoOut "Removing ${dialogLog} …"
        rm "${dialogLog}"
    fi

    # Remove updateDialogLog
    if [[ -f "${updateDialogLog}" ]]; then
        infoOut "Removing ${updateDialogLog} …"
        rm "${updateDialogLog}"
    fi

    # Remove Admin Access
    if [ $renewProfiles = "true" ]; then
        infoOut "Removing admin access from computer"
        removeAdmin
    else
        infoOut "Renew Profiles was set to $renewProfiles, skipping removing admin access from computer"
    fi

    quitOut "Goodbye!"
    exit 

}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Create Folder Path
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Create Folder Path
function folderPath() {

    if [[ -f "${folder_path}" ]]; then
        infoOut "Specified folder path exists"
    elif [[ ! -f "${folder_path}" ]]; then
        infoOut "Created specified folder path"
        mkdir -p ${folder_path}
    else
        infoOut "Specified folder path exists; writing log entries to it"
    fi

}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Functions to pull API information
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Get JSON value
function get_json_value() {
    # set -x
    JSON="$1" osascript -l 'JavaScript' \
        -e 'const env = $.NSProcessInfo.processInfo.environment.objectForKey("JSON").js' \
        -e "JSON.parse(env).$2"
    # set +x
}

# Extract from JSON
function extract_from_json() {
  echo "$1" | awk -v key="$2" '
    BEGIN {
      RS = "[},]";
      FS = "[:,]";
    }
    {
      for (i = 1; i <= NF; i += 2) {
        if ($i ~ "\"" key "\"") {
          gsub(/["{}]/, "", $(i + 1));
          gsub(/^[\t ]+|[\t ]+$/, "", $(i + 1));
          print $(i + 1);
          exit;
        }
      }
    }
  '
}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Add to Admin Group
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Add to Admin Group
function addAdmin() {
    if dseditgroup -o checkmember -m "$loggedInUser" admin | grep -q "not a member"; then
        infoOut "${loggedInUser} is not an admin. Adding to the admin group..."
        updateDialog "progresstext: Adding ${loggedInUser} to the admin group..."
        sudo /usr/sbin/dseditgroup -o edit -a "$loggedInUser" -t user admin
        infoOut "${loggedInUser} has been added to the admin group."
        updateDialog "progresstext: ${loggedInUser} has been added to the admin group."
    else
        infoOut "${loggedInUser} is already an admin."
        updateDialog "progresstext: ${loggedInUser} is already an admin."
    fi
}


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Remove from Admin Group
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Remove from Admin Group
function removeAdmin () {
    if dseditgroup -o checkmember -m "$loggedInUser" admin | grep -q "is a member"; then
        quitOut "$loggedInUser is an admin. Removing from the admin group..."
        sudo /usr/sbin/dseditgroup -o edit -d "$loggedInUser" -t user admin
        quitOut "$loggedInUser has been removed from the admin group."
    else
        quitOut "$loggedInUser is not an admin."
    fi
}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Find User Accounts and Remove
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

function completeReEnrollDialog() {

    infoOut "Checking if Dialog is running or closed for another prompt"

    if pgrep -x "Dialog" >/dev/null; then
        infoOut "Dialog is running."
        infoOut "ReEnroll dialog is still running, proceeding"
        updateDialog "ontop: enabled"
        updateDialog "listitem: delete, title: ReEnroll in progress …,"
        updateDialog "icon: SF=checkmark.circle.fill,weight=bold,colour1=#00ff44,colour2=#075c1e"
        updateDialog "overlayicon: $overlayicon"
        updateDialog "progress: 100"
        updateDialog "progresstext: Done!"
        infoOut "Elapsed Time: $(printf '%dh:%dm:%ds\n' $((SECONDS/3600)) $((SECONDS%3600/60)) $((SECONDS%60)))"
        sleep 10
    else
        infoOut "Dialog closed at some point. Calling window to show complete"
        eval "$dialogReEnroll" &
        infoOut "Complete ReEnroll dialog"
        updateDialog "icon: SF=checkmark.circle.fill,weight=bold,colour1=#00ff44,colour2=#075c1e"
        updateDialog "listitem: delete, title: ReEnroll in progress …"
        updateDialog "listitem: add, title: ReEnroll Complete, icon: $overlayicon, statustext: Complete, status: success"
        updateDialog "overlayicon: $overlayicon"
        updateDialog "progress: 100"
        updateDialog "progresstext: Done!"
        infoOut "Elapsed Time: $(printf '%dh:%dm:%ds\n' $((SECONDS/3600)) $((SECONDS%3600/60)) $((SECONDS%60)))"
        sleep 10
    fi

}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Find User Accounts and Remove
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Find User Accounts and Remove
function findUsersandRemove() {

  # Demote LAPS admin account
  if [ "$skipAccountDeletion" = "false" ]; then
    notice "Skip Account Deletion is set to false, proceeding"

    # Check if $exempt_users is not empty
    if [ -z "${exempt_users[*]}" ] && [ "$skipAccountDeletion" = "false" ]; then
        error "exempt_users is empty"
    fi

    # Check if $targeted_users is not empty
    if [ -z "${targeted_users[*]}" ] && [ "$skipAccountDeletion" = "false" ]; then
        error "targeted_users is empty"
    fi

    # Check if $lapsAdminAccount is not empty
    if [ -z "$lapsAdminAccount" ] && [ "$skipAccountDeletion" = "false" ]; then
        error "lapsAdminAccount is empty"
    fi

    # Demote LAPS admin account to be removed
    infoOut "Demoting $lapsAdminAccount account"

sudo dseditgroup -o edit -d $lapsAdminAccount -t user admin

RESULT=()

# Read the list of users with UniqueID greater than 500
while read -r user; do
    userHome=$(dscl . read /Users/"$user" NFSHomeDirectory | awk '{print $NF}')

    found_in_exempt_list=false

    for exempt_user in "${exempt_users[@]}"; do
        if [[ "$user" == "$exempt_user" ]]; then
            RESULT+=("$(infoOut "Found user $user in exempt list, ignoring...\n")")
            found_in_exempt_list=true
            break
        fi
    done

     # Check if user is a local admin
    if ! $found_in_exempt_list; then
        RESULT+=("$(infoOut "User $user not found in exempt list, checking admin status...\n")")
        if dseditgroup -o checkmember -u "$user" admin 1 >/dev/null; then
            RESULT+=("$(infoOut "User $user was found to be a Local Admin, ignoring...\n")")
        else
            # Check if user is in targeted list
            for targeted_user in "${targeted_users[@]}"; do
                if [[ "$user" == "$targeted_user" ]]; then
                    RESULT+=("$(infoOut "Found user $user in targeted list, $userHome will be deleted...\n")")
                    dscl . delete /Users/"$user"
                    rm -rf "$userHome"
                    break
                fi
            done
        fi
    fi
    done < <(dscl . list /Users UniqueID | awk '$2 > 500 {print $1}')

    echo -e "${RESULT[@]}"

    elif [ "$skipAccountDeletion" = "" ]; then
        infoOut "Skip Account Deletion is set blank, skipping"
    else
        infoOut "Skip Account Deletion is set to true, skipping"
    fi
}

# Add Device Enrolled Receipt
function enrollDeviceReceipt() {

    infoOut "Adding device enrolled receipt"
    echo "Enrolled Device" > "$receipt_path"

}

# Checks results from bearer token - pass result from token commands.
function check_token() {

    apitokenCheck=$(/usr/bin/curl --write-out "%{http_code}" --silent --output /dev/null "${jssurl}api/v1/auth" --request GET --header "Authorization: Bearer ${apiBearerToken}")
    infoOut "API Bearer Token Check: ${apitokenCheck}"
    case ${apitokenCheck} in
        200)
            infoOut "API Bearer Token is Valid"
            APIResult="Token Good"
            ;;
        401)
            error "Authentication failed. Verify the credentials and URL being used for the request."
            APIResult="Failure"
            ;;
        403)
            error "Invalid permissions. Verify the account being used has the proper permissions for the resource you are trying to access."
            APIResult="Failure"
            ;;
        404)
            error "The resource you are trying to access could not be found. Check the URL and try again." 
            APIResult="Failure"
            ;;
        *)
            error "Unknown error. Status code: ${apitokenCheck}"
            APIResult="Failure"
            ;;
    esac
}

# Checks results from various commands - pass result from commands.
function check_status() {
	if [[ $1 == *"Bad Request"* || $1 == *"httpStatus"* || $1 == *"Access Denied"* || $1 == *"Status page"* ]]; then
		APIResult="Failure"
	else
		APIResult="Command Sent"
	fi
}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Jamf Binary Re-Deploy
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Obtain Jamf Pro Bearer Token via Basic Authentication
function getAccessToken() {

    tokenResponse=$(curl --silent --location --request POST "${jssurl}api/oauth/token" \
        --header "Content-Type: application/x-www-form-urlencoded" \
        --data-urlencode "client_id=${client_id}" \
        --data-urlencode "grant_type=client_credentials" \
        --data-urlencode "client_secret=${client_secret}")

    if [[ "${osMajorVersion}" -lt 12 ]]; then
        apiBearerToken=$(/usr/bin/awk -F \" 'NR==2{print $4}' <<< "$tokenResponse" | /usr/bin/xargs)
    else
        apiBearerToken=$(echo "$tokenResponse" | plutil -extract access_token raw -)
    fi
    check_token "$tokenResponse"
    #check_token "$tokenResponse"
    if [ "$APIResult" = "Failure" ]; then
        APIAccess="Failure"
        error "API Access result: $APIAccess"
    elif [ "$APIResult" = "Token Good" ]; then
        infoOut "API Bearer Token obtained"
        APIAccess="Success"
        infoOut "API Access result: $APIAccess"
        token_expires_in=$(echo "$tokenResponse" | plutil -extract expires_in raw -)
        current_epoch=$(date +%s)
        token_expiration_epoch=$((current_epoch + token_expires_in - 1))
    else
        error "API Bearer Token could not be obtained, check API credentials and API permissions"
        APIAccess="Failure"
    fi
    echo $APIAccess > /dev/null 2>&1
}

# Check if Bearer Token is still valid
function checkTokenExpiration() {
    current_epoch=$(date +%s)
    if (( token_expiration_epoch >= current_epoch ))
    then
        token_expiration_date=$(date -r "$token_expiration_epoch" "+%Y-%m-%d %H:%M:%S %Z")
        notice "Token valid until: $token_expiration_date"
    else
        infoOut "No valid token available, getting new token"
        getAccessToken
    fi
}

# Jamf Management Framework Re-Deploy
function jmfrdeploy() {

    # Send API request to get the computer inventory details
    function apiResponse() {

        response=$(curl -s -X GET \
            -H "Authorization: Bearer $apiBearerToken" \
            -H "Accept: application/xml" \
            "{$jssurl}JSSResource/computers/serialnumber/$serialNumber")

    }

    # Extract the computer ID from the response
    function computerIDLookup() {

        # Extract the computer ID based on the serial number from the response using xmllint and sed
        computerID=$(echo "$response" | xmllint --xpath 'string(/computer/general/id)' - | sed 's/[^0-9]*//g')

        if [[ "$debugMode" = "verbose" ]]; then
            debugVerbose "Computer ID: $computerID"
        fi

        # Send API request to get the computer inventory details
        managmentIDAPI=$(curl -s -X GET \
            -H "Authorization: Bearer $apiBearerToken" \
            -H "accept: application/json" \
            "${jssurl}api/v1/computers-inventory-detail/$computerID")
        check_status "$managmentIDAPI"
        if [ "$APIResult" = "Failure" ]; then
            errorOut "Failed to gather computer inventory, error: $APIResult"
        else
            infoOut "Successfully gathered computer inventory, result: $APIResult"
        fi

        # Extract the management ID from the response using awk
        management_id=$(extract_from_json "$managmentIDAPI" "managementId")

        # If the managementId is not directly in the top-level JSON object,
        # try extracting from the "general" key
        if [ -z "$management_id" ]; then
            management_id=$(extract_from_json "$managmentIDAPI" "general:managementId")
        fi

        if [[ "$debugMode" = "verbose" ]]; then
            debugVerbose "Management ID: $management_id"
        fi
    }

    # Get computer inventory details
    function computerInventoryInfo () {

    generalComputerInfo=$(/usr/bin/curl -H "Authorization: Bearer ${apiBearerToken}" -H "Accept: text/xml" -sfk "${jssurl}JSSResource/computers/id/${computerID}/subset/General" -X GET)
    check_status "$generalComputerInfo"
    if [ "$APIResult" = "Failure" ]; then
        errorOut "Failed to get general computer info, error: $APIResult"
    else
        infoOut "Successfully gathered general computer info, result: $APIResult"
    fi

    hardwareComputerInfo=$(/usr/bin/curl -H "Authorization: Bearer ${apiBearerToken}" -H "Accept: text/xml" -sfk "${jssurl}JSSResource/computers/id/${computerID}/subset/Hardware" -X GET)
    check_status "$hardwareComputerInfo"
    if [ "$APIResult" = "Failure" ]; then
        errorOut "Failed to get hardware computer info, error: $APIResult"
    else
        infoOut "Successfully gathered hardware computer info, result: $APIResult"
    fi

    computerName=$(echo "${generalComputerInfo}" | xpath -q -e "/computer/general/name/text()")
    computerSerialNumber=$(echo "${generalComputerInfo}" | xpath -q -e "/computer/general/serial_number/text()")
    computerModel=$( echo "${hardwareComputerInfo}" | xpath -q -e "/computer/hardware/model/text()" )
    computerIpAddress=$(echo "${generalComputerInfo}" | xpath -q -e "/computer/general/ip_address/text()")
    computerIpAddressLastReported=$(echo "${generalComputerInfo}" | xpath -q -e "/computer/general/last_reported_ip/text()")
    computerSite=$(echo "${generalComputerInfo}" | xpath -q -e "/computer/general/site/name/text()")
    computerSiteID=$(echo "${generalComputerInfo}" | xpath -q -e "/computer/general/site/id/text()")
    
    infoOut "Computer Site ID: $computerSiteID"
    infoOut "Computer Site Name: $computerSite"
    infoOut "Computer Model: $computerModel"

    if [[ "$debugMode" = "verbose" ]]; then
        debugVerbose "Redeploy Jamf Management Framework for:"
        debugVerbose "• Name: $computerName"
        debugVerbose "• Serial Number: $computerSerialNumber"
        debugVerbose "• Computer Model: $computerModel"
        debugVerbose "• IP Address: $computerIpAddress"
        debugVerbose "• IP Address (LR): $computerIpAddressLastReported"
        debugVerbose "• Computer Site: $computerSite"
        debugVerbose "• Computer Site: $computerSiteID"
        debugVerbose "• Server: ${jssurl}"
        debugVerbose "• Computer ID: ${computerID}"
    fi
    }

    # Clear all failed MDM Commands
    function clearFailedCommands () {
    # Brute-force clear all failed MDM Commands
    notice "Brute-force clear all failed MDM Commands"
    clearFailedCommandsResult=$(/usr/bin/curl -H "Authorization: Bearer ${apiBearerToken}" "${jssurl}JSSResource/commandflush/computers/id/${computerID}/status/Failed" -X DELETE)
    check_status "$clearFailedCommandsResult"

    if [ "$APIResult" = "Failure" ]; then
        errorOut "Failed to clear all failed MDM Commands, error: $APIResult"
    else
        infoOut "Cleared all failed MDM Commands, result: $APIResult"
    fi

    if [ "$APIResult" = "Failure" ]; then
        error "API Command flush could not be cleared, result: $APIAccess"
        updateDialog "listitem: add, title: Gathering Computer Information, icon: SF=pencil.and.list.clipboard,weight=bold, statustext: Error, status: error"
    elif [ "$APIResult" = "Command Sent" ]; then
        infoOut "All Failed MDM Commands have been cleared, result: $APIResult"
         updateDialog "listitem: title: Gathering Computer Information, icon: SF=pencil.and.list.clipboard,weight=bold, statustext: Complete, status: success"
    else
        error "API Command flush could not be cleared, check API credentials and API permissions"
        updateDialog "listitem: add, title: Gathering Computer Information, icon: SF=pencil.and.list.clipboard,weight=bold, statustext: Error, status: error"
    fi
    }

    # Redeploy Jamf binary
    function redeployFramework () {
    # Redeploy Jamf binary
    notice "Redeploy Jamf binary"
    redeployResult=$(/usr/bin/curl -H "Authorization: Bearer ${apiBearerToken}" -H "accept: application/json" --progress-bar --fail-with-body "${jssurl}"api/v1/jamf-management-framework/redeploy/"${computerID}" -X POST)
    check_status "$redeployResult"

    if [ $displayReEnrollDialog = "true" ]; then
        if [ "$APIResult" = "Failure" ]; then
            updateDialog "listitem: title: Deploy Jamf Framework, icon: SF=icloud.and.arrow.down.fill,weight=bold, statustext: Error, status: error"
            updateDialog "progresstext: Jamf Management Framework unable to redeploy"
            errorOut "Jamf Management Framework unable to redeploy, error: $APIResult"
        else
            updateDialog "listitem: title: Deploy Jamf Framework, icon: SF=icloud.and.arrow.down.fill,weight=bold, statustext: Complete, status: success"
            updateDialog "progresstext: Jamf Management Framework redeployed"
            infoOut "Jamf Management Framework redeployed, result: $APIResult"
        fi
    else
        # Display dialog is set to false, do nothing
        infoOut "Display ReEnroll Dialog set to false, skipping dialog"
    fi
    }

    APIAccess=$(getAccessToken)
    updateDialog "progresstext: Checking token expiration"
    checkTokenExpiration
    updateDialog "progresstext: Getting API access token"
    #getAccessToken
    updateDialog "progresstext: Checking for API credentials"
    if [ -z "$client_id" ] || [ -z "$client_secret" ] || [ "$APIAccess" = "Failure" ]; then
                notice "API credentials not set or API Access Failure, skipping getting computer inventory"
                updateDialog "progresstext: API credentials are not set or API Access Failure"
    elif [ -n "$client_id" ] && [ -n "$client_secret" ] || [ "$APIAccess" = "Success" ]; then
                updateDialog "listitem: add, title: Gathering Computer Information, icon: SF=pencil.and.list.clipboard,weight=bold, statustext: Checking …, status: wait"
                updateDialog "listitem: delete, title: ReEnroll in progress …,"
                infoOut "API credentials set, continuing"
                updateDialog "progresstext: API credentials set, continuing"
                # API information and computer inventory functions
                #updateDialog "progresstext: Getting API access token"
                #getAccessToken
                apiResponse
                #updateDialog "progresstext: Checking token expiration"
                #checkTokenExpiration
                computerIDLookup
                updateDialog "progresstext: Checking computer inventory"
                computerInventoryInfo
                updateDialog "progresstext: Clearing failed MDM commands"
                clearFailedCommands
                    # Checking if display ReEnroll Dialog and 'Redeploy Framework' set to true
                    if [ $displayReEnrollDialog = "true" ] && [ "$redeployFramework" = "true" ]; then
                        infoOut "Display ReEnroll Dialog and 'Redeploy Framework' set to true"
                        updateDialog "listitem: title: Gathering Computer Information, icon: SF=pencil.and.list.clipboard,weight=bold, statustext: Complete, status: success"
                        updateDialog "listitem: add, title: Deploy Jamf Framework, icon: SF=icloud.and.arrow.down.fill,weight=bold, statustext: Checking…, status: wait"
                        updateDialog "listitem: delete, title: ReEnroll in progress …,"
                        updateDialog "progresstext: Checking for API credentials"
                        # Redeploy Jamf management framework is set to true, proceeding with redeploy
                        updateDialog "progresstext: Jamf Management Framework deploying"
                        redeployFramework
                    elif [ $displayReEnrollDialog = "false" ] && [ "$redeployFramework" = "true" ]; then
                        # Redeploy Jamf management framework is set to true, proceeding with redeploy with displayReEnrollDialog set to false
                        infoout "Display ReEnroll Dialog set to false and 'Redeploy Framework' set to true, skipping dialog"
                        # Redeploy Jamf management framework is set to true, proceeding with redeploy
                        redeployFramework
                    else
                        # Redeploy Jamf management framework is set to false, skipping redeploy
                        notice "Skipping Redeploy of Jamf management framework with displayReEnrollDialog set to false and 'Redeploy Framework' set to false"
                    fi
    elif [ -n "$client_id" ] && [ -n "$client_secret" ] || [ "$APIAccess" = "Failure" ]; then
        error "API credentials not set or API Access Failure, skipping getting computer inventory"
        updateDialog "progresstext: API credentials are not set or API Access Failure"
        updateDialog "listitem: add, title: Gathering Computer Information, icon: SF=pencil.and.list.clipboard,weight=bold, statustext: Error, status: error"
    else
        # Redeploy Jamf management framework is set to false, skipping redeploy
        notice "Skipping Redeploy of Jamf management framework"
    fi
}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Check for a Jamf Pro server connection
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Check for Jamf Pro server connection
function jssConnectionStatus() {

    scriptResult+="Check for Jamf Pro server connection; "

    unset jssStatus
    jssStatus=$(/usr/local/bin/jamf checkJSSConnection 2>&1 | /usr/bin/tr -d '\n')

    case "${jssStatus}" in

    *"The JSS is available."        ) jssAvailable="yes" ;;
    *"No such file or directory"    ) jssAvailable="not installed" ;;
    *                               ) jssAvailable="unknown" ;;

    esac

}
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Validate policy check in after enrollment
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Validate policy
function validatePolicy() {

    marker_file="/var/tmp/jamfTempMarker.txt"
    jamfLogFile="/var/log/jamf.log"
    duplicate_jamfLogFile="$duplicate_log_dir/jamf_position_$timestamp.log"

    # Find the last position marker or start from the beginning if not found
    if [ -f "$marker_file" ]; then
        lastPosition=$(cat "$marker_file")
    else 
        lastPosition=0
    fi

    # Copy new entries from jamf.log to the duplicate log file
    tail -n +$((lastPosition + 1)) "$jamfLogFile" >> "$duplicate_jamfLogFile" 

    # Update the marker file with the new position
    wc -l "$jamfLogFile" | awk '{print $1}' > "$marker_file"

    lastPosition=$(cat "$marker_file")
    if [[ "$debugMode" = "verbose" ]]; then
        debugVerbose "Last jamf.log position: $lastPosition"
    fi

    # Process the last line of the log
    policyStatus=$( tail -n1 "$duplicate_jamfLogFile" | awk -F': ' '{print $NF}' | sed -e 's/Removing existing launchd task \/Library\/LaunchDaemons\/com.jamfsoftware.task.bgrecon.plist... //g' )

    # Read jamf log for debug
    currentPolicyStatus=$( tail -n1 "$duplicate_jamfLogFile" | awk -F': ' '{print $NF}' | sed -e 's/Removing existing launchd task \/Library\/LaunchDaemons\/com.jamfsoftware.task.bgrecon.plist... //g' )

    if [ "$redeployFramework" = "false" ] || [ "$sendEnrollmentInvitation" = "false" ] || [ "$renewProfiles" = "false" ]; then
        # Determine the status based on the processed log entry
        case "${policyStatus}" in
            *"No patch policies were found."                                                                 ) policyStatus="yes" ;;
            *"Removing existing launchd task /Library/LaunchDaemons/com.jamfsoftware.task.bgrecon.plist..."  ) policyStatus="yes" ;;
            *"There was an error.

            Unknown Error - An unknown error has occurred"                                                   ) policyStatus="connection error" ;;
            *                                                                                                ) policyStatus="unknown" ;;
        esac
    else
        # Determine the status based on the processed log entry
        case "${policyStatus}" in
            *"Checking for policies triggered by \"enrollmentComplete\" for user \"${loggedInUser}\"..."     ) policyStatus="yes" ;;
            *"Enroll return code:"                                                                           ) policyStatus="yes" ;;
            *"There was an error.

            Unknown Error - An unknown error has occurred"                                                   ) policyStatus="connection error" ;;
            *                                                                                                ) policyStatus="unknown" ;;
        esac
    fi

    # Debug output
    if [ "$debugMode" = "verbose" ]; then
        debugVerbose "Current policyStatus: $policyStatus"
        debugVerbose "Current jamf.log status: $currentPolicyStatus"
    fi
}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Validate inventory after enrollment
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Validate inventory
function validateInventory() {

    scriptResult+="Check for Jamf Pro inventory connection; "

    inventoryStatus=$( tail -n1 "$tempInventoryLog" | sed -e 's/verbose: //g' -e 's/Found app: \/System\/Applications\///g' -e 's/Utilities\///g' -e 's/Found app: \/Applications\///g' -e 's/Running script for the extension attribute //g' )

    case "${inventoryStatus}" in

    *"Removing existing launchd task /Library/LaunchDaemons/com.jamfsoftware.task.bgrecon.plist..."           ) inventoryStatus="yes" ;;
    *"There was an error.

     Unknown Error - An unknown error has occurred"                                                           ) inventoryStatus="connection error" ;;
    *                                                                                                         ) inventoryStatus="unknown" ;;

    esac

}
# Enrollment function
function triggerEnrollment () {
	notice "Displaying enrollment window"
	/bin/launchctl asuser "${uid}" /usr/bin/profiles renew -type enrollment
}

# Delete LAPS account
function deleteLAPSAccount () {
    if [ "$skipAccountDeletion" = "false" ]; then
        notice "Skip Account Deletion is set to false, proceeding"
            if [ -n "$lapsAdminAccount" ]; then
                notice "Deleting LAPS account: ${lapsAdminAccount}"
                /usr/bin/dscl . -delete /Users/"$lapsAdminAccount"
            else
                notice "No LAPS account to delete"
            fi
    elif [ "$skipAccountDeletion" = "" ]; then
        infoOut "Skip Account Deletion is set blank, skipping"
    else
        infoOut "Skip Account Deletion is set to true, skipping"
    fi
}

# Display ReEnroll - Profile Renew dialog
function jamfProfileRenew () {

    # Display ReEnroll dialog for profiles renewal
    dialogUpdateReEnroll="$dialogBinary \
    --title \"Jamf Update Needed\" \
    --titlefont \"name=Arial, size=25\" \
    --icon \"$icon\" \
    --iconsize 90 \
    --overlayicon \"$overlayicon\" \
    --message \"Hello! Jamf, your Apple management software, needs to be updated. \n\nPlease choose **Options** and **Update** from the drop down menu, or double-click on the **Device Enrollment** notice located in your notifications center.\" \
    --messagefont \"name=Arial,size=15\" \
    --position bottomright \
    --height 355 \
    --width 530 \
    --button1text \"Update Now\" \
    --infobuttontext \"Not Now\" \
    --helpmessage \"$helpMessage\" \
    --timer 600 \
    --hidetimerbar \
    --ontop \
    --moveable \
    --messagealignment left \
    --commandfile \"$updateDialogLog\" "

    eval "$dialogUpdateReEnroll"
    
}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Send notification to update profiles
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Send dialog notification and profiles renew command
function inventoryError() {

    # Check is displayReEnrollDialog is true
    if [ $displayReEnrollDialog = "true" ]; then
        notice "Adding 'Profiles Renew' dialog"
        updateDialog "listitem: add, title: Jamf Update Needed, icon: SF=exclamationmark.icloud.fill,weight=bold, statustext: Waiting …, status: wait"
        updateDialog "listitem: delete, title: ReEnroll in progress …,"
        updateDialog "progresstext: Waiting for update decision..."
    else
        notice "ReEnroll did not call for 'Profiles Renew' dialog"
    fi
    notice "Sending Profiles Renew Command, deleting LAPS account, and sending notification"
    echo "ReEnroll with notification" >> $receipt_path
    webhookStatus="ReEnroll with notification"
    reEnrollMethod="Notification for Renewing Enrollment"
        if [[ "${osMajorVersion}" -ge 12 ]] && [[ -e "/Library/Application Support/Dialog/Dialog.app" ]]; then
            infoOut "Sending Dialog notification for updating profiles"

            # Display ReEnroll dialog for profiles renewal
            jamfProfileRenew
                
            returncode=$?

            if [ "$debugMode" = "verbose" ]; then
            debugVerbose "Return Code: ${returncode}"
            fi

            case ${returncode} in

                0)  ## Process exit code 0 scenario here
                    notice "${loggedInUser} clicked Update Now;"
                    infoOut "Checking user admin status to renew profiles"
                        addAdmin
                        sleep 5
                        triggerEnrollment
                        deleteLAPSAccount
                        updateDialog "listitem: title: Jamf Update Needed, icon: SF=arrow.clockwise.icloud.fill,weight=bold, statustext: Update Pending, status: pending"
                        updateDialog "progresstext: Update command sent. Waiting for response..."
                        updateDialog "progresstext: Check for update notification in your Notifications Center"
                        sleep 60
                            # Verifying if we need to send check-in
                            if [ "$skipCheckIN" = "false" ]; then
                                notice "Skipping check-in option is false, sending check-in command"
                                updateDialog "listitem: title: Jamf Update Needed, icon: SF=arrow.clockwise.icloud.fill,weight=bold, statustext: , status: nothing"
                                checkIn
                            else
                                # skipCheckIN was set to true
                                notice "Skipping check-in command"
                                updateDialog "listitem: title: Jamf Update Needed, icon: SF=arrow.clockwise.icloud.fill,weight=bold, statustext: Update Command Sent, status: nothing"
                                sleep 30
                            fi
                        quitScript "0"
                    ;;

                3)  ## Process exit code 2 scenario here
                    notice "${loggedInUser} clicked Not Now;"
                    updateDialog "listitem: title: Jamf Update Needed, icon: SF=arrow.clockwise.icloud.fill,weight=bold, statustext: Deferring Update, status: nothing"
                    infoOut "Removing enrollment receipt"
                    webhookStatus="ReEnroll with notification"
                    reEnrollMethod="Customer Chose: Not Now"
                    rm -rf /usr/local/TS/receipts/reEnrollComputer.txt
                    quitScript "0"
                    ;;

                4)  ## Process exit code 4 scenario here
                    notice "${loggedInUser} allowed timer to expire;"
                    updateDialog "listitem: title: Jamf Update Needed, icon: SF=arrow.clockwise.icloud.fill,weight=bold,"
                    infoOut "Removing enrollment receipt"
                    webhookStatus="ReEnroll with notification"
                    reEnrollMethod="Customer allowed timer to expire"
                    rm -rf /usr/local/TS/receipts/reEnrollComputer.txt
                    quitScript "0"
                    ;;

                20) ## Process exit code 20 scenario here
                    updateScriptLog "${loggedInUser} had Do Not Disturb enabled"
                    updateDialog "listitem: title: Jamf Update Needed, icon: SF=arrow.clockwise.icloud.fill,weight=bold,"
                    infoOut "Removing enrollment receipt"
                    webhookStatus="ReEnroll with notification"
                    reEnrollMethod="Customer had Do Not Disturb enabled"
                    rm -rf /usr/local/TS/receipts/reEnrollComputer.txt
                    quitScript "0"
                    ;;

                *)  ## Catch all processing
                    infoOut "Something else happened; Exit code: ${returncode};"
                    updateDialog "listitem: title: Jamf Update Needed, icon: SF=arrow.clockwise.icloud.fill,weight=bold,"
                    infoOut "Removing enrollment receipt"
                    webhookStatus="ReEnroll with notification"
                    reEnrollMethod="Something went wrong, policy will run at next execution"
                    rm -rf /usr/local/TS/receipts/reEnrollComputer.txt
                    quitScript "${returncode}"
                    ;;

            esac
        else
            infoOut "Sending osascript notification for updating profiles"
            echo "ReEnroll with notification" >> $receipt_path
            infoOut "Sending Profiles Renew Enrollment Command"
            triggerEnrollment
            webhookStatus="ReEnroll with notification (S/N ${serialNumber})"
            reEnrollMethod="Notification for Renewing Enrollment"
            updateProfilesOSA='display dialog "Hello! Jamf, your Apple management software, needs to be updated. \n\nPlease choose Options and Update from the drop down menu, or double-click on the Device Enrollment notice located in your notifications center." with title "Jamf Update Needed" buttons {"Close"} with icon posix file "/Applications/Self-Service Hub.app/Contents/Resources/AppIcon.icns"'
            /usr/bin/osascript -e "$updateProfilesOSA"
        fi
    error "Jamf Pro Inventory or Policy Connection is NOT available; exiting."
    quitScript "1"
}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Create Launch Daemon to run locally
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Create launch daemon, set permissions and start
function reconLaunchDaemon() {

# create organization folder if necessary to house the jamf-recon.zsh script
if [[ "$debugMode" = "verbose" ]]; then
    debugVerbose "Creating organization folder if necessary to house the jamf-recon.zsh script"
    debugVerbose "Creating jamf-recon.zsh script"
    debugVerbose "Setting correct ownership and permissions on jamf-recon.zsh script jamf-recon.zsh script"
    debugVerbose "Creating $organizationReverseDomain.jamf-recon.plist launch daemon"
    debugVerbose "Setting correct ownership and permissions on launch daemon"
    debugVerbose "Setting start launch daemon after policy"
fi

# create organization folder if necessary to house the jamf-recon.zsh script
/bin/mkdir -p "/Library/$organizationName"

# create jamf-recon.zsh script
tee "/Library/$organizationName/jamf-recon.zsh" << EOF
#!/bin/zsh

# Update Jamf Pro inventory
/usr/local/bin/jamf recon -endUsername "$networkUser" 

# Update Jamf Pro policy
/usr/local/bin/jamf policy

# Rotate Jamf Pro Management Account Password, if needed
if [ "$sendEnrollmentInvitation" = "true" ]; then
    echo "Attempting to rotateManagement Account Password"
    /usr/local/bin/jamf rotateManagementAccountPassword
else
    echo "Management Account Password will not be rotated"
fi

# Check if the user is an admin
if dseditgroup -o checkmember -m $loggedInUser admin | grep -q "is a member"; then
    echo "$loggedInUser is an admin. Removing from the admin group..."
    /usr/bin/sudo dseditgroup -o edit -d $loggedInUser -t user admin
    echo "$loggedInUser has been removed from the admin group."
else
    echo "$loggedInUser is not an admin."
fi

# delete this script
/bin/rm "/Library/$organizationName/jamf-recon.zsh"

# attempt to delete enclosing directory
/bin/rmdir "/Library/$organizationName"

# delete the launch daemon plist
/bin/rm "/Library/LaunchDaemons/$organizationReverseDomain.jamf-recon.plist"

# kill the launch daemon process
/bin/launchctl remove "$organizationReverseDomain.jamf-recon"

exit 0
EOF

# set correct ownership and permissions on jamf-recon.zsh script
/usr/sbin/chown root:wheel "/Library/$organizationName/jamf-recon.zsh" && /bin/chmod +x "/Library/$organizationName/jamf-recon.zsh"

# create $organizationReverseDomain.jamf-recon.plist launch daemon
tee /Library/LaunchDaemons/$organizationReverseDomain.jamf-recon.plist << EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>EnvironmentVariables</key>
	<dict>
		<key>PATH</key>
		<string>/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</string>
	</dict>
	<key>Label</key>
	<string>$organizationReverseDomain.jamf-recon</string>
	<key>ProgramArguments</key>
	<array>
		<string>/bin/zsh</string>
		<string>-c</string>
		<string>"/Library/$organizationName/jamf-recon.zsh"</string>
	</array>
	<key>RunAtLoad</key>
	<true/>
	<key>StartInterval</key>
	<integer>1</integer>
</dict>
</plist>
EOF

# set correct ownership and permissions on launch daemon
/usr/sbin/chown root:wheel /Library/LaunchDaemons/$organizationReverseDomain.jamf-recon.plist && /bin/chmod 644 /Library/LaunchDaemons/$organizationReverseDomain.jamf-recon.plist

# start launch daemon after installation
/bin/launchctl bootstrap system /Library/LaunchDaemons/$organizationReverseDomain.jamf-recon.plist && /bin/launchctl start /Library/LaunchDaemons/$organizationReverseDomain.jamf-recon.plist

}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Verify LAPS Account information
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Function to check if a user exists
function check_user_exists() {
  local username="$1"
  if id -u "${username}" >/dev/null 2>&1; then
    # User exists
    return 0
    infoOut "Admin account ${lapsAdminAccount} exist..."
    updateDialog "progresstext: LAPS Admin Account exists..."
  else
    # User does not exist
    return 1
    infoOut "Admin account ${lapsAdminAccount} does not exist..."
    updateDialog "progresstext: LAPS Admin Account does not exists..."
  fi
}

# Function to validate user's password
# Description: Validate the LAPS password for the given user.
function validate_password() {
    # Check if the API token has expired
    checkTokenExpiration

    # Send API request to get the LAPS password
    lapsPasswordInformation=$( curl -X 'GET' \
        "${jssurl}"api/v2/local-admin-password/"${management_id}"/account/"${lapsAdminAccount}"/password \
        -H 'accept: application/json' \
        -H "Authorization: Bearer ${apiBearerToken}"
        )
    check_status "$lapsPasswordInformation"
    if [ "$APIResult" = "Failure" ]; then
        errorOut "Failed to gather LAPS Password, error: $APIResult"
    else
        infoOut "Successfully gathered LAPS Password, result: $APIResult"
    fi
    # Extract the LAPS password from the response using awk    
    lapsPassword=$(get_json_value "$lapsPasswordInformation" 'password' )

    # Check password and capture the result
    infoOut "Authenticating $lapsAdminAccount password..."
    updateDialog "progresstext: Checking LAPS Admin Password credentials..."
    # Check if the password is ok
    dscl /Local/Default -authonly "$lapsAdminAccount" "$lapsPassword"
    authResult=$?

    if [ $authResult -eq 0 ]; then
        infoOut "$lapsAdminAccount authentication succeeded"
        updateDialog "progresstext: LAPS Admin Account Password are valid..."
    else
        error "$lapsAdminAccount authentication failed"
        updateDialog "progresstext: LAPS Admin Account Password are invalid..."
    fi

}

# Function to check LAPS password
function checkLAPSAccount() {

  if ! check_user_exists "$lapsAdminAccount"; then
    error "User $lapsAdminAccount does not exist."
    return 1
  fi

  infoOut "Checking password for user $lapsAdminAccount..."
  validate_password
  # Check password and capture the result 
  if [ $authResult -eq 0 ]; then
    notice "Password for user $lapsAdminAccount is correct."
    return 0
  else
    error "Password for user $lapsAdminAccount is incorrect."
    return 1
  fi
}

function updateLAPSPassword() {
# Generate a random password for the LAPS account
randomPassword=$(openssl rand -base64 29 | tr -d '=' | cut -c 1-30)

checkTokenExpiration
apiResponse
computerIDLookup

# Send API request to set the LAPS password
setLAPSPassword=$(/usr/bin/curl -X 'PUT' \
    --url "${jssurl}api/v2/local-admin-password/$management_id/set-password" \
    -H 'accept: application/json' \
    -H "Authorization: Bearer $apiBearerToken" \
    -H 'Content-Type: application/json' \
    -d "{
    \"lapsUserPasswordList\": [
        {
        \"username\": \"$lapsAdminAccount\",
        \"password\": \"$randomPassword\"
        }
    ]
    }"
)
check_status "$setLAPSPassword"
if [ "$APIResult" = "Failure" ]; then
    errorOut "Failed to set LAPS Password, error: $APIResult"
else
    infoOut "Successfully set LAPS Password, result: $APIResult"
fi
}

# Function to rotate LAPS password
function rotateLAPSPassword() {

    # Check if the API token has expired
    checkTokenExpiration

    # Send API request to get the LAPS password
    notice "Sending rotate Management Account Password command..."

    updateDialog "progresstext: Checking enrollment..."
    # Update the LAPS password
    updateLAPSPassword
    
    #Sleeping 10 seconds before sending rotate Management Account Password command
    sleep 10

    infoOut "Sending Rotate Management Account Password Command "
    # Send command to rotate the LAPS password
    /usr/local/bin/jamf rotateManagementAccountPassword

    # Check if the LAPS password was successfully rotated
    verifyLAPSCredentials
    #quitScript
}

# Function send enrollment invitation
function reEnrollInvitation() {

    if [ "$enrollmentInvitation" = "" ] || [ "$sendEnrollmentInvitation" = "false" ]; then
        # enrollmentInvitation is empty or enrollmentInvitation is set to "false"
        error "Enrollment invitation is empty, not sending invitation"
        updateDialog "The enrollment invitation is empty or incorrect, unable to send invitation"
    else
        infoOut "Send Enrollment Invitation is set to true and enrollment invitation is not empty"
        updateDialog "listitem: add, title: Sending Enrollment Invitation, icon: SF=paperplane.circle.fill,weight=bold, statustext: Sending …, status: wait"
        updateDialog "listitem: delete, title: ReEnroll in progress …,"
        updateDialog "progresstext: Sending Enrollment Invitation..."

        if [ "$lapsAdminAccount" = "" ]; then
            # lapsAdminAccount is empty
            notice "LAPS Admin Account is empty, not deleting LAPS account"
        else
            infoOut "Deleting ${lapsAdminAccount}"
            # Delete LAPS account and send invitation to create new account
            deleteLAPSAccount
        fi    

        infoOut "Sending Silent Enrollment Invitation"
        # Send enrollment invitation
        /usr/local/bin/jamf enroll -invitation "$enrollmentInvitation" -noRecon -noPolicy
        updateDialog "listitem: title: Sending Enrollment Invitation, icon: SF=person.crop.circle.fill.badge.checkmark,weight=bold, statustext: Invitation Sent, status: success"
        updateDialog "progresstext: Enrollment Invitation Sent"

        # Set webhook statuses
        reEnrollMethod="Sending Silent Enrollment Invitation"
        webhookStatus="ReEnroll without notification"

        # rorate LAPSPassword if needed
        rotateLAPSPassword
fi

}
# Function to delete LAPS account and send invitation
function verifyLAPSCredentials() {
    
  scriptResult+="Check for LAPS account and password; "
  #lap_Status=1
  # Loop to retry checking the LAPS account status
  LAPScounter=1
  until [[ "$lap_Status" -eq 0 ]] || [[ "$LAPScounter" -gt 2 ]]; do
    scriptResult+="Check ${LAPScounter} of 1: LAPS account not valid; waiting to re-check; "
    sleep 60
    checkLAPSAccount "$jssurl" "$management_id" "$apiBearerToken" "$lapsAdminAccount" "$lapsPassword"
    lap_Status=$?

    if [[ "$lap_Status" -ne 0 ]]; then
      notice "Sending enrollment invitation..."
      # Check enrollment invitation status
      reEnrollInvitation
    fi

    ((counter++))
  done
}

# Function to check the LAPS account status and handle enrollment
function checkLAPSAccountStatus() {
  
  if [ $displayReEnrollDialog = "true" ]; then
    notice "Adding 'LAPS Admin Check' dialog"
    updateDialog "listitem: add, title: LAPS Admin Check, icon: SF=person.crop.circle.badge.clock.fill,weight=bold, statustext: Checking …, status: wait"
    updateDialog "listitem: delete, title: ReEnroll in progress …,"
    updateDialog "progresstext: Checking LAPS Admin Account credentials..."
  else
    notice "ReEnroll did not call for 'LAPS Admin Check'"
  fi

  # Loop to retry checking the LAPS account status
  verifyLAPSCredentials

  if [[ "$lap_Status" -eq 0 ]]; then
    infoOut "LAPS account and password are valid"
    updateDialog "listitem: title: LAPS Admin Check, icon: SF=person.crop.circle.fill.badge.checkmark,weight=bold, statustext: Valid Credentials, status: success"
    updateDialog "listitem: title: Sending Enrollment Invitation, icon: SF=person.crop.circle.fill.badge.checkmark,weight=bold, statustext: Invitation Sent, status: success"
    #scriptResult+="LAPS account and password are valid; "
    echo "ReEnroll without notification" >> $receipt_path
    webhookStatus="ReEnroll without notification"
    
    # Only update reEnrollMethod if it hasn't been set already
    if [[ -z "$reEnrollMethod" ]]; then
      reEnrollMethod="Silent Redeploy of the Jamf Management Framework"
    fi

    if [ $skipLaunchDaemon = "false" ]; then
        infoOut "$skipLaunchDaemon is set to false, sending Recon Launch Daemon"
        reconLaunchDaemon
        quitScript "0"
    else 
        infoOut "$skipLaunchDaemon is set to true, skipping sending Recon Launch Daemon"
        quitScript "0"
    fi

  else
    #scriptResult+="LAPS account and password could not be validated after 10 attempts"
    updateDialog "listitem: title: LAPS Admin Check, icon: SF=person.crop.circle.fill.badge.xmark,weight=bold, statustext: Invalid Credentials …, status: fail"
    updateDialog "listitem: title: Sending Enrollment Invitation, icon: SF=person.crop.circle.fill.badge.xmark,weight=bold, statustext: Invalid Credentials …, status: fail"
    error "LAPS account and password could not be validated"
    infoOut "Sending Profiles Renew Command"
    echo "ReEnroll with notification" >> $receipt_path
    webhookStatus="ReEnroll with notification"
    # Sending renew profiles dialog
    inventoryError
  fi
}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Jamf Check for Inventory and Policies
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Function to check if the JSS is reachable, if inventory is available, and if the policy is running
function checkIn() {

    # Count errors
    errorCount=0

    # Validating JSS Connection Status
    jssConnectionStatus
        if [ $displayReEnrollDialog = "true" ]; then
            notice "Adding 'Jamf Connection Status' dialog"
            updateDialog "listitem: add, title: Jamf Connection Status, icon: SF=icloud.and.arrow.up.fill,weight=bold, statustext: Check 1 of 3, status: wait"
            updateDialog "listitem: delete, title: ReEnroll in progress …,"
            updateDialog "listitem: add, title: • JSS Connection, statustext: Checking …, status: wait"
            updateDialog "listitem: add, title: • Policy Status, statustext: Pending …"
            updateDialog "listitem: add, title: • Inventory Status, statustext: Pending …"
            updateDialog "progresstext: Checking Jamf Software Server (JSS)"
        else
            notice "ReEnroll did not call for 'LAPS Admin Check'"
        fi

    counter=1

    # Loop to retry checking the JSS
    until [[ "${jssAvailable}" = "yes" ]] || [[ "${counter}" -gt "10" ]]; do
        scriptResult+="Check ${counter} of 10: Jamf Pro server NOT reachable; waiting to re-check; "
        sleep "30"
        jssConnectionStatus
        ((counter++))
    done

    # If JSS is reachable
    if [[ "${jssAvailable}" = "yes" ]]; then
        infoOut "Jamf Pro server is available, proceeding"
        infoOut "Reading Jamf log for Policy Status"
        updateDialog "listitem: title: Jamf Connection Status, icon: SF=icloud.and.arrow.up.fill,weight=bold, statustext: Check 2 of 3, status: wait"
        updateDialog "listitem: title: • JSS Connection, icon: SF=icloud.and.arrow.up.fill,weight=bold, statustext: Connected, status: success"
        updateDialog "listitem: title: • Policy Status, statustext: Checking …, status: wait"
        updateDialog "progresstext: Policies allow you to remotely automate common management tasks on managed computers."

        # Validate policy
        #/usr/local/bin/jamf policy
        validatePolicy
        counterPolicy=1

        # Loop to retry checking the policy connection
        until [[ "${policyStatus}" = "yes" ]] || [[ "${counterPolicy}" -gt "120" ]]; do
            scriptResult+="Check ${counterPolicy} of 120: Jamf Pro Policy Connection Error; "
            if [[ "$debugMode" = "verbose" ]]; then
                debugVerbose "Check Policy count ${counterPolicy} of 120"
            fi
            sleep "2"
            validatePolicy
            ((counterPolicy++))
        done

        # If policy is running
        if [[ "${policyStatus}" = "yes" ]]; then
            infoOut "Jamf Pro Policy Connection is stable, proceeding"
            updateDialog "listitem: title: • Policy Status, icon: SF=icloud.and.arrow.up.fill,weight=bold, statustext: Connected, status: success"
        else
            error "Unable to verify Jamf Pro Policy Check In, proceeding"
            updateDialog "listitem: title: • Policy Status, icon: SF=exclamationmark.icloud.fill, statustext: Unable to Verify, status: error"
        fi
		
        # Terminating Jamf Check-In
        infoOut "Terminating Jamf Check-In"
        pkill jamf

        # Pausing for 5 seconds
        sleep 5
        updateDialog "listitem: title: Jamf Connection Status, icon: SF=icloud.and.arrow.up.fill,weight=bold, statustext: Check 3 of 3, status: wait"
        updateDialog "listitem: title: • Inventory Status, statustext: Checking …, status: wait"
        updateDialog "progresstext: Jamf Pro stores detailed inventory information for each computer."

        # Force computer to submit inventory
        infoOut "Forcing computer to submit inventory"
        /usr/local/bin/jamf recon -endUsername "${networkUser}" --verbose >> $tempInventoryLog

        # Validating Jamf Pro Inventory
        validateInventory
        counterInventory=1

        # Loop to retry checking the inventory
        until [[ "${inventoryStatus}" = "yes" ]] || [[ "${counterInventory}" -gt "4" ]]; do
            scriptResult+="Check ${counterInventory} of 4: Jamf Pro Inventory Connection Error; "
            if [[ "$debugMode" = "verbose" ]]; then
                debugVerbose "Check Inventory count ${counterInventory} of 4"
            fi 
            sleep "30"
            validateInventory
            ((counterInventory++))
        done

        # If inventory is running
        if [[ "${inventoryStatus}" = "yes" ]]; then
            infoOut "Jamf Pro Inventory Connection is stable, proceeding"
            updateDialog "listitem: title: • Inventory Status, icon: SF=icloud.and.arrow.up.fill,weight=bold, statustext: Connected, status: success"
            updateDialog "listitem: title: Jamf Connection Status, icon: SF=icloud.and.arrow.up.fill,weight=bold, statustext: Success, status: success"
        else
            # Sending Inventory error notification and profiles renew
            error "Jamf Pro Inventory Connection status error"
            updateDialog "listitem: title: • Inventory Status, icon: SF=exclamationmark.icloud.fill, statustext: Connection Error, status: error"
            updateDialog "listitem: title: Jamf Connection Status, icon: SF=icloud.and.arrow.up.fill,weight=bold, statustext: Connection Error, status: error"
            inventoryError
        fi

        # Verify LAPS credentials needs to be skipped or not
        if [[ "$skipLAPSAdminCheck" = "false" ]]; then
           notice "Skip LAPS admin Account verification is set to false, proceeding"
           # Verify LAPS credentials
           checkLAPSAccountStatus
        else
            notice "Skip LAPS admin Account verification is set to true, skipping"
        fi

    else
        updateDialog "listitem: title: Jamf Connection Status, icon: SF=icloud.and.arrow.up.fill,weight=bold, statustext: Connection Error …, status: error"
        updateDialog "listitem: title: • JSS Connection, icon: SF=exclamationmark.icloud.fill, statustext: Connection Error …, status: error"
        updateDialog "progresstext: No connection could be established"
        # Sending Inventory error notification and profiles renew
        inventoryError
    fi

}


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Webhook Message (Microsoft Teams or Slack) 
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Function to send webhook message
function webHookMessage() {

if [[ $slackURL == "" ]]; then
    infoOut "No slack URL configured"
else
    if [[ $supportTeamHyperlink == "" ]]; then
        supportTeamHyperlink="https://www.slack.com"
    fi
if [[ -z "$clientID" || -z "$clientPassword" ]] || [ "$APIAccess" = "Failure" ]; then
  webhookComputerModel="$modelName"
else
  webhookComputerModel="$computerModel"
fi
    infoOut "Sending Slack WebHook"
    curl -s -X POST -H 'Content-type: application/json' \
        -d \
        '{
	"blocks": [
		{
			"type": "header",
			"text": {
				"type": "plain_text",
				"text": "'${scriptName}': '"${webhookStatus}"'",
			}
		},
		{
			"type": "divider"
		},
		{
			"type": "section",
			"fields": [
				{
					"type": "mrkdwn",
					"text": ">*Serial Number and Computer Name:*\n>'"$serialNumber"' on '"$computerName"'"
				},
                		{
					"type": "mrkdwn",
					"text": ">*Computer Model:*\n>'"$webhookComputerModel"'"
				},
				{
					"type": "mrkdwn",
					"text": ">*Current User:*\n>'"$loggedInUserFirstname $loggedInUserLastname (NetID: $loggedInUser)"'"
				},
				{
					"type": "mrkdwn",
					"text": ">*Notification Status:*\n>'"$webhookStatus"'"
				},
                {
					"type": "mrkdwn",
					"text": ">*ReEnrollment Method:*\n>'"$$reEnrollMethod"'"
				},
                {
					"type": "mrkdwn",
					"text": ">*Computer Record:*\n>'"$jamfProComputerURL"'"
				}
			]
		},
		{
		"type": "actions",
			"elements": [
				{
					"type": "button",
					"text": {
						"type": "plain_text",
						"text": "View computer in Jamf Pro",
						"emoji": true
					},
					"style": "primary",
					"action_id": "actionId-0",
					"url": "'"$jamfProComputerURL"'"
				}
			]
		}
	]
}' \
        "$slackURL"
fi

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Teams notification (Credit to https://github.com/nirvanaboi10 for the Teams code)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

if [[ $teamsURL == "" ]]; then
    infoOut "No teams Webhook configured"
else
    if [[ $supportTeamHyperlink == "" ]]; then
        supportTeamHyperlink="https://www.microsoft.com/en-us/microsoft-teams/"
    fi
if [[ -z "$clientID" || -z "$clientPassword" ]] || [ "$APIAccess" = "Failure" ]; then
  webhookComputerModel="$modelName"
else
  webhookComputerModel="$computerModel"
fi
    infoOut "Sending Teams WebHook"
    jsonPayload='{
	"@type": "AdaptiveCard",
	"@context": "http://schema.org/extensions",
	"themeColor": "0076D7",
	"summary": "'${scriptName}': '${webhookStatus}'",
	"sections": [{
		"activityTitle": "'${scriptName}': '${webhookStatus}'",
		"activityImage": "https://raw.githubusercontent.com/AndrewMBarnett/ReEnroll/refs/heads/main/Extras/Images/systemSettings.png",
		"facts": [{
			"name": "Computer Name (Serial Number):",
			"value": "'"$computerName"' ('"$serialNumber"')"
		}, {
			"name": "Computer Model:",
			"value": "'"$webhookComputerModel"'"
		}, {
			"name": "Current User:",
			"value": "'"$loggedInUserFirstname $loggedInUserLastname (NetID: $loggedInUser)"'"
		}, {
			"name": "Notification Status:",
			"value": "'"$webhookStatus"'"
        }, {
        	"name": "ReEnrollment Method:",
			"value": "'"$reEnrollMethod"'"
        }, {
			"name": "Computer Record:",
			"value": "'"$jamfProComputerURL"'"
		}],
		"markdown": true
	}],
	"potentialAction": [{
		"@type": "OpenUri",
		"name": "View in Jamf Pro",
		"targets": [{
			"os": "default",
			"uri":
			"'"$jamfProComputerURL"'"
		}]
	}]
}'

    # Send the JSON payload using curl
    curl -s -X POST -H "Content-Type: application/json" -d "$jsonPayload" "$teamsURL"

fi

}

# Functions for script
if [ "$displayReEnrollDialog" = "true" ]; then
    evalReEnrollDialog
else
    # displayReEnrollDialog was set to false
    notice "Skipping ReEnroll Dialog"
fi

# Create Folder Paths if they don't exist
folderPath

# Find Users and Remove
findUsersandRemove

# Add Enroll Device Receipt
enrollDeviceReceipt

# Check API Token Credentials
if [ -z "$client_id" ] || [ -z "$client_secret" ]; then
    error "No API client credentials provided"
else
    # Check API Token
    #checkTokenExpiration
    jmfrdeploy
fi

# ReDeploy Framework
#jmfrdeploy

# Verifying if we need to send an enrollment invitation
case ${sendEnrollmentInvitation} in

    "true" ) # Send enrollment invitation 
        infoOut "Enrollment Invitation set to: ${sendEnrollmentInvitation}"
        reEnrollInvitation
    ;;

    "failure" ) # Send enrollment invitation on failures
        infoOut "Enrollment Invitation set to: ${sendEnrollmentInvitation}, enrollment invitation will be sent if the Jamf Framework deployment reports failures"
    ;;

    "false" ) # Don't notify
        infoOut "Enrollment Invitation set to: ${sendEnrollmentInvitation}, skipping ..."
    ;;

    * ) # Catch-all
        infoOut "Enrollment Invitation set to: ${sendEnrollmentInvitation}, skipping ..."
        ;;

    esac

# Verifying if we need to send renew profiles
case ${renewProfiles} in

    "true" ) # Send profiles renew command
        infoOut "Profiles Renew set to: ${renewProfiles}"
        inventoryError
    ;;

    "failure" ) # Send profiles renew command on failures
        infoOut "Profiles Renew set to: ${renewProfiles}, profiles renew command will be sent if the Jamf Framework deployment reports failures and the ReEnroll Invitation command fails"
    ;;

    "false" ) # Don't notify
        infoOut "Profiles Renew set to: ${renewProfiles}, skipping ..."
    ;;

    * ) # Catch-all
        infoOut "Enrollment Invitation set to: ${renewProfiles}, skipping ..."
        ;;

    esac

# Verifying if we need to send check-in
if [ "$skipCheckIN" = "false" ]; then
    notice "Skipping check-in option is false, sending check-in command"
    checkIn
    if [ "$redeployFramework" = "false" ] || [ "$sendEnrollmentInvitation" = "false" ] || [ "$renewProfiles" = "false" ] || [ "$skipLAPSAdminCheck" = "false" ]; then
        notice "Only check-in command was sent, exiting script"
        quitScript "0"
    else
        notice "All commands were sent"
    fi
else
    # skipCheckIN was set to true
    notice "Skipping check-in command"
fi

# Verifying if we need to send LAPS admin check
if [ "$skipLAPSAdminCheck" = "false" ]; then
    notice "Skipping LAPS admin check option is false, sending LAPS admin check command"
    checkLAPSAccountStatus
else
    # skipLAPSAdminCheck was set to true
    notice "Skipping LAPS admin check command"
fi

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Sideways Exit
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

quitScript "1"
